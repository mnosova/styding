<!DOCTYPE html>
<html lang="ru-RU">
<head>
	<meta charset="utf-8">
	<title>Site Name / Learn JavaScript.Структура</title><!--[if IE]>
	<meta http-equiv="X-UA-Compatible" content="IE = edge"><![endif]-->
	<meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<script src="../js/learnjs-proto.js"></script>
</head>
<style>
	body, html {
		margin: 0;
		padding: 0;
	}

	p {
		margin: 5px 0 10px;
	}
</style>
<body>
<div class="content">
	<header>
		<ul>
			<li><a href="blockly.html">Blockly</a></li>
			<li><a href="learnjsbasic.html">Learn JavaScript.Основы</a></li>
			<li><a href="learnjsstructure.html">Learn JavaScript.Структура</a></li>
			<li><a href="work.html">Рабочие задачки</a></li>
			<li><a href="proto.html">Learn JavaScript.Функции.Прототипы,классы,наследование</a></li>
		</ul>
	</header>
	<div class="page page__learnjsproto">
		<p><b> Рекурсия и стек </b></p>
		<p>
			Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
			Например:
			sumTo(1) = 1
			sumTo(2) = 2 + 1 = 3
			sumTo(3) = 3 + 2 + 1 = 6
			sumTo(4) = 4 + 3 + 2 + 1 = 10
			...
			sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
			Сделайте три варианта решения:
			С использованием цикла.
			Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.
			С использованием формулы арифметической прогрессии.
			Пример работы вашей функции:
			function sumTo(n) { /*... ваш код ... */ }
			alert( sumTo(100) ); // 5050
			P.S. Какой вариант решения самый быстрый? Самый медленный? Почему?
			P.P.S. Можно ли при помощи рекурсии посчитать sumTo(100000)?
		</p>
		<button onclick="console.log(sumTo(4))">запуск</button>
		<button onclick="console.log(sumToRec(4))">запуск</button>
		<button onclick="console.log(sumToArifm(4))">запуск</button>
		<p>
			Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
			Определение факториала можно записать как:
			n! = n * (n - 1) * (n - 2) * ...*1
			Примеры значений для разных n:
			1! = 1
			2! = 2 * 1 = 2
			3! = 3 * 2 * 1 = 6
			4! = 4 * 3 * 2 * 1 = 24
			5! = 5 * 4 * 3 * 2 * 1 = 120
			Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.
			alert( factorial(5) ); // 120
			P.S. Подсказка: n! можно записать как n * (n-1)! Например: 3! = 3*2! = 3*2*1! = 6
		</p>
		<button onclick="console.log(factorial(4))">запуск</button>
		<p>
			Числа Фибоначчи
			важность: 5
			Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
			Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
			Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.
			Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.
			Пример работы:
			function fib(n) { /* ваш код */ }
			alert(fib(3)); // 2
			alert(fib(7)); // 13
			alert(fib(77)); // 5527939700884757
			P.S. Все запуски функций из примера выше должны работать быстро. Вызов fib(77) должен занимать не более доли секунды.
		</p>
		<button onclick="console.log(fib(7))">запуск</button>
		<button onclick="console.log(fib2(7))">запуск</button>
		<p>
			Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):
			let list = {
			value: 1,
			next: {
			value: 2,
			next: {
			value: 3,
			next: {
			value: 4,
			next: null
			}
			}
			}
			};
			Напишите функцию printList(list), которая выводит элементы списка по одному.
			Сделайте два варианта решения: используя цикл и через рекурсию.
			Как лучше: с рекурсией или без?
		</p>
		<!--<button onclick="console.log(printList(list))">запуск</button>-->
		<p>
			Выведите односвязный список из предыдущего задания Вывод односвязного списка в обратном порядке.
			Сделайте два решения: с использованием цикла и через рекурсию.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Замыкание </b></p>
		<p>
			Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
			Да, именно таким образом, используя двойные круглые скобки (не опечатка).
			Например:
			sum(1)(2) = 3
			sum(5)(-1) = 4
		</p>
		<button onclick="console.log(chainSum(1)(2))">запуск</button>
		<button onclick="console.log(testSome())">запуск</button>
		<p>
			У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f. Если она возвращает true, то элемент добавится в возвращаемый массив.
			Сделайте набор «готовых к употреблению» фильтров:
			inBetween(a, b) – между a и b (включительно).
			inArray([...]) – находится в данном массиве.
			Они должны использоваться таким образом:
			arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
			arr.filter(inArray([1,2,3])) – выбирает только элементы, совпадающие с одним из элементов массива
			Например:
			/* .. ваш код для inBetween и inArray */
			let arr = [1, 2, 3, 4, 5, 6, 7];
			alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
			alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
		</p>
		<button onclick="console.log(filtred())">запуск</button>
		<p>
			У нас есть массив объектов, который нужно отсортировать:
			let users = [
			{ name: "John", age: 20, surname: "Johnson" },
			{ name: "Pete", age: 18, surname: "Peterson" },
			{ name: "Ann", age: 19, surname: "Hathaway" }
			];
			Обычный способ был бы таким:
			// по имени (Ann, John, Pete)
			users.sort((a, b) => a.name > b.name ? 1 : -1);
			// по возрасту (Pete, Ann, John)
			users.sort((a, b) => a.age > b.age ? 1 : -1);
			Можем ли мы сделать его короче, скажем, вот таким?
			users.sort(byField('name'));
			users.sort(byField('age'));
			То есть, чтобы вместо функции, мы просто писали byField(fieldName).
			Напишите функцию byField, которая может быть использована для этого.
		</p>
		<button onclick="console.log(sortBy())">запуск</button>
		<p>
			Следующий код создаёт массив из стрелков (shooters).
			Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так…
			function makeArmy() {
			let shooters = [];
			let i = 0;
			while (i < 10) {
			let shooter = function() { // функция shooter
			alert( i ); // должна выводить порядковый номер
			};
			shooters.push(shooter);
			i++;
			}
			return shooters;
			}
			let army = makeArmy();
			army[0](); // у 0-го стрелка будет номер 10
			army[5](); // и у 5-го стрелка тоже будет номер 10
			// ... у всех стрелков будет номер 10, вместо 0, 1, 2, 3...
			Почему у всех стрелков одинаковые номера? Почините код, чтобы он работал как задумано.
		</p>
		<button onclick="console.log(army[1]())">запуск</button>
		<p><b> Объект функции, NFE </b></p>
		<p>
			Измените код makeCounter() так, чтобы счётчик мог увеличивать и устанавливать значение:
			counter() должен возвращать следующее значение (как и раньше).
			counter.set(value) должен устанавливать счётчику значение value.
			counter.decrease() должен уменьшать значение счётчика на 1.
			Посмотрите код из песочницы с полным примером использования.
			P.S. Для того, чтобы сохранить текущее значение счётчика, можно воспользоваться как замыканием, так и свойством функции. Или сделать два варианта решения: и так, и так.
			Открыть песочницу с тестами для задачи.
		</p>
		<button onclick="console.log(showCountner())">запуск</button>
		<p>
			Напишите функцию sum, которая бы работала следующим образом:
			sum(1)(2) == 3; // 1 + 2
			sum(1)(2)(3) == 6; // 1 + 2 + 3
			sum(5)(-1)(2) == 6
			sum(6)(-1)(-2)(-3) == 0
			sum(0)(1)(2)(3)(4)(5) == 15
			P.S. Подсказка: возможно вам стоит сделать особый метод преобразования в примитив для функции.
		</p>
		<button onclick="console.log(showChainSum2())">запуск</button>
		<p><b> Планирование: setTimeout и setInterval</b></p>
		<p>
			Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.
			Сделайте два варианта решения.
			Используя setInterval.
			Используя рекурсивный setTimeout.
		</p>
		<button onclick="console.log(printNumbers(2,8))">запуск</button>
		<button onclick="console.log(printNumbers2(2,8))">запуск</button>
		<p>
			В приведённом ниже коде запланирован вызов setTimeout, а затем выполняется сложное вычисление, для завершения которого требуется более 100 мс.
			Когда будет выполнена запланированная функция?
			После цикла.
			Перед циклом.
			В начале цикла.
			Что покажет alert?
			let i = 0;
			setTimeout(() => alert(i), 100); // ?
			// предположим, что время выполнения этой функции >100 мс
			for(let j = 0; j < 100000000; j++) {
			i++;
			}
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Декораторы и переадресация вызова, сall/apply </b></p>
		<p>
			Создайте декоратор spy(func), который должен возвращать обёртку, которая сохраняет все вызовы функции в своём свойстве calls.
			Каждый вызов должен сохраняться как массив аргументов.
			Например:
			function work(a, b) {
			alert( a + b ); // произвольная функция или метод
			}
			work = spy(work);
			work(1, 2); // 3
			work(4, 5); // 9
			for (let args of work.calls) {
			alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
			}
			P.S.: Этот декоратор иногда полезен для юнит-тестирования. Его расширенная форма – sinon.spy – содержится в библиотеке Sinon.JS.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. Например:
			function f(x) {
			alert(x);
			}
			// создаём обёртки
			let f1000 = delay(f, 1000);
			let f1500 = delay(f, 1500);
			f1000("test"); // показывает "test" после 1000 мс
			f1500("test"); // показывает "test" после 1500 мс
			Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».
			В приведённом выше коде f – функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст this.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Результатом декоратора debounce(f, ms) должна быть обёртка, которая передаёт вызов f не более одного раза в ms миллисекунд. Другими словами, когда мы вызываем debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.
			Например:
			let f = debounce(alert, 1000);
			f(1); // выполняется немедленно
			f(2); // проигнорирован
			setTimeout( () => f(3), 100); // проигнорирован (прошло только 100 мс)
			setTimeout( () => f(4), 1100); // выполняется
			setTimeout( () => f(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
			На практике debounce полезен для функций, которые получают/обновляют данные, и мы знаем, что повторный вызов в течение короткого промежутка времени не даст ничего нового. Так что лучше не тратить на него ресурсы.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку, передавая вызов в f не более одного раза в ms миллисекунд. Те вызовы, которые попадают в период «торможения», игнорируются.
			Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.
			Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.
			Например, мы хотим отслеживать движения мыши.
			В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду (каждые 10 мс).
			Мы бы хотели обновлять информацию на странице при передвижениях.
			…Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Да и нет смысла делать обновление чаще, чем один раз в 100 мс.
			Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 100) как функцию, которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но передавать вызов в update() максимум раз в 100 мс.
			Визуально это будет выглядеть вот так:
			Для первого движения указателя декорированный вариант сразу передаёт вызов в update. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.
			Затем, когда указатель продолжает движение, в течение 100 мс ничего не происходит. Декорированный вариант игнорирует вызовы.
			По истечению 100 мс происходит ещё один вызов update с последними координатами.
			Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 100 мс, и затем вызывает update с последними координатами. В итоге окончательные координаты указателя тоже обработаны.
			Пример кода:
			function f(a) {
			console.log(a)
			}
			// f1000 передаёт вызовы f максимум раз в 1000 мс
			let f1000 = throttle(f, 1000);
			f1000(1); // показывает 1
			f1000(2); // (ограничение, 1000 мс ещё нет)
			f1000(3); // (ограничение, 1000 мс ещё нет)
			// когда 1000 мс истекли ...
			// ...выводим 3, промежуточное значение 2 было проигнорировано
			P.S. Аргументы и контекст this, переданные в f1000, должны быть переданы в оригинальную f.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Привязка контекста к функции </b></p>
		<p>
			Вызов askPassword() в приведённом ниже коде должен проверить пароль и затем вызвать user.loginOk/loginFail в зависимости от ответа.
			Однако, его вызов приводит к ошибке. Почему?
			Исправьте выделенную строку, чтобы всё работало (других строк изменять не надо).
			function askPassword(ok, fail) {
			let password = prompt("Password?", '');
			if (password == "rockstar") ok();
			else fail();
			}
			let user = {
			name: 'Вася',
			loginOk() {
			alert(`${this.name} logged in`);
			},
			loginFail() {
			alert(`${this.name} failed to log in`);
			},
			};
			askPassword(user.loginOk, user.loginFail);
		</p>
		<button onclick="console.log(askPassword(user3.loginOk.bind(user3), user3.loginFail.bind(user3)))">запуск</button>
		<p>
			Это задание является немного усложнённым вариантом одного из предыдущих – Исправьте функцию, теряющую "this".
			Объект user был изменён. Теперь вместо двух функций loginOk/loginFail у него есть только одна – user.login(true/false).
			Что нужно передать в вызов функции askPassword в коде ниже, чтобы она могла вызывать функцию user.login(true) как ok и функцию user.login(false) как fail?
			function askPassword(ok, fail) {
			let password = prompt("Password?", '');
			if (password == "rockstar") ok();
			else fail();
			}
			let user = {
			name: 'John',
			login(result) {
			alert( this.name + (result ? ' logged in' : ' failed to log in') );
			}
			};
			askPassword(?, ?); // ?
			Ваши изменения должны затрагивать только выделенный фрагмент кода.
		</p>
		<button onclick="console.log(askPassword2(() => user4.login(true), () => user4.login(false)))">запуск</button>
		<button onclick="console.log(askPassword2(askPassword(user.login.bind(user4, true), user.login.bind(user4, false))))">запуск</button>
		<p><b>Прототипное наследование</b></p>
		<p>Задача состоит из двух частей.
		   У нас есть объекты:
		   let head = {
		   glasses: 1
		   };
		   let table = {
		   pen: 3
		   };
		   let bed = {
		   sheet: 1,
		   pillow: 2
		   };
		   let pockets = {
		   money: 2000
		   };
		   С помощью свойства __proto__ задайте прототипы так, чтобы поиск любого свойства выполнялся по следующему пути: pockets → bed → table → head. Например, pockets.pen должно возвращать значение 3 (найденное в table), а bed.glasses – значение 1 (найденное в head).
		   Ответьте на вопрос: как быстрее получить значение glasses – через pockets.glasses или через head.glasses? При необходимости составьте цепочки поиска и сравните их.
		</p>
		<button onclick="console.log(protoChain())">запуск</button>
		<p>
			У нас есть два хомяка: шустрый (speedy) и ленивый (lazy); оба наследуют от общего объекта hamster.
			Когда мы кормим одного хомяка, второй тоже наедается. Почему? Как это исправить?
			let hamster = {
			stomach: [],
			eat(food) {
			this.stomach.push(food);
			}
			};
			let speedy = {
			__proto__: hamster
			};
			let lazy = {
			__proto__: hamster
			};
			// Этот хомяк нашёл еду
			speedy.eat("apple");
			alert( speedy.stomach ); // apple
			// У этого хомяка тоже есть еда. Почему? Исправьте
			alert( lazy.stomach ); // apple
		</p>
		<button onclick="console.log(humster())">запуск</button>
		<p><b>F.prototype</b></p>
		<p>Создайте новый объект с помощью уже существующего
		   важность: 5
		   Представьте, что у нас имеется некий объект obj, созданный функцией-конструктором – мы не знаем какой именно, но хотелось бы создать ещё один объект такого же типа.
		   Можем ли мы сделать так?
		   let obj2 = new obj.constructor();
		   Приведите пример функции-конструктора для объекта obj, с которой такой вызов корректно сработает. И пример функции-конструктора, с которой такой код поведёт себя неправильно.
		   решение</p>
		<button onclick="console.log(protoConstructor())">запуск</button>
		<p><b>Встроенные прототипы</b></p>
		<p>
			Добавьте всем функциям в прототип метод defer(ms), который вызывает функции через ms миллисекунд.
			После этого должен работать такой код:
			function f() {
			alert("Hello!");
			}
			f.defer(1000); // выведет "Hello!" через 1 секунду
		</p>
		<button onclick="console.log(addFuncMethod())">запуск</button>
		<p>
			Добавьте всем функциям в прототип метод defer(ms), который возвращает обёртку, откладывающую вызов функции на ms миллисекунд.
			Например, должно работать так:
			function f(a, b) {
			alert( a + b );
			}
			f.defer(1000)(1, 2); // выведет 3 через 1 секунду.
			Пожалуйста, заметьте, что аргументы должны корректно передаваться оригинальной функции.
		</p>
		<!--<button onclick="console.log(addFuncMethod2())">запуск</button>-->
		<p><b>Методы прототипов, объекты без свойства __proto__</b></p>
		<p>
			Имеется объект dictionary, созданный с помощью Object.create(null) для хранения любых пар ключ/значение.
			Добавьте ему метод dictionary.toString(), который должен возвращать список ключей, разделённых запятой. Ваш toString не должен выводиться при итерации объекта с помощью цикла for..in.
			Вот так это должно работать:
			let dictionary = Object.create(null);
			// ваш код, который добавляет метод dictionary.toString
			// добавляем немного данных
			dictionary.apple = "Apple";
			dictionary.__proto__ = "test"; // здесь __proto__ -- это обычный ключ
			// только apple и __proto__ выведены в цикле
			for(let key in dictionary) {
			alert(key); // "apple", затем "__proto__"
			}
			// ваш метод toString в действии
			alert(dictionary); // "apple,__proto__"
		</p>
		<button onclick="addSpecial()">запуск</button>
		<p><b>Класс: базовый синтаксис</b></p>
		<p>
			Перепишите класс
			Класс Clock написан в функциональном стиле. Перепишите его, используя современный синтаксис классов.
			P.S. Часики тикают в консоли. Откройте её, чтобы посмотреть.
		</p>
		<button onclick="newClock()">запуск</button>
		<p><b>Наследование протатипов</b></p>
		<p>
			В коде ниже класс Rabbit наследует Animal.

			К сожалению, объект класса Rabbit не создаётся. Что не так? Исправьте ошибку.

			class Animal {

			constructor(name) {
			this.name = name;
			}
			}

			class Rabbit extends Animal {
			constructor(name) {
			this.name = name;
			this.created = Date.now();
			}
			}

			let rabbit = new Rabbit("Белый кролик"); // Error: this is not defined
		</p>
		<button onclick="newRabbit()">запуск</button>
		<p>
			Создайте новый класс ExtendedClock, который будет наследоваться от Clock и добавьте параметр precision – количество миллисекунд между «тиками». Установите значение в 1000 (1 секунда) по умолчанию.
		</p>
		<button onclick="newClock2()">запуск</button>
		<button onclick="test()"></button>
	</div>
</div>
</body>
</html>