<!DOCTYPE html>
<html lang="ru-RU">
<head>
	<meta charset="utf-8">
	<title>Site Name / Learn JavaScript.Структура</title><!--[if IE]>
	<meta http-equiv="X-UA-Compatible" content="IE = edge"><![endif]-->
	<meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<script src="../js/learnjsstructure-js.js"></script>
</head>
<style>
	body, html {
		margin: 0;
		padding: 0;
	}

	p {
		margin: 5px 0 10px;
	}
</style>
<body>
<div class="content">
	<header>
		<ul>
			<li><a href="blockly.html">Blockly</a></li>
			<li><a href="learnjsbasic.html">Learn JavaScript.Основы</a></li>
			<li><a href="learnjsstructure.html">Learn JavaScript.Структура</a></li>
			<li><a href="work.html">Рабочие задачки</a></li>
			<li><a href="proto.html">Learn JavaScript.Прототипы,классы,наследование</a></li>
		</ul>
	</header>
	<div class="page page__learnjsstructire">
		<p><b>Числа</b></p>
		<p>
			Создайте страницу, которая предлагает ввести два числа и выводит их сумму.P.S. Есть «подводный камень» при работе с типами.</p>
		<p>
			<button onclick="console.log( sum() )">запуск</button>
		</p>
		<p>
			Создайте функцию readNumber, которая будет запрашивать ввод числового значения до тех пор, пока посетитель его не введёт.
			Функция должна возвращать числовое значение.
			Также надо разрешить пользователю остановить процесс ввода, отправив пустую строку или нажав «Отмена». В этом случае функция должна вернуть null.
		</p>
		<p>
			<button onclick="console.log( readNumber() )">запуск</button>
		</p>
		<p>
			Получится глупо, если при заказе двух товаровс ценами 0.10$ и 0.20$ человек получит общую стоимость 0.30000000000000004$;
			alert( 0.1 + 0.2 + '$' );
			Что можно сделать, чтобы избежать проблем с ошибками округления?
		</p>
		<p>
			<button onclick="console.log( mnojItem() )">запуск</button>
		</p>
		<p>Напишите код для генерации случайного значения в диапазоне от 0 до max, не включая max.</p>
		<p>
			<button onclick="console.log( random(10) )">запуск</button>
		</p>
		<p>Напишите код для генерации случайного числа от min до max, не включая max.</p>
		<p>
			<button onclick="console.log( randomBetween(8,19) )">запуск</button>
		</p>
		<p>
			Напишите функцию randomInteger(min, max) для генерации случайного целого числа между min и max, включая min,max как возможные значения.Любое число из интервала min..max должно иметь одинаковую вероятность.</p>
		<p>
			<button onclick="console.log( randomInteger(1,10) )">запуск</button>
		</p>
		<p><b>Строки</b></p>
		<p>
			Напишите функцию ucFirst(str), которая возвращает строку str с заглавным первым символом, например:ucFirst("вася") == "Вася";
			ucFirst("") == ""; // нет ошибок при пустой строке
			P.S. В JavaScript нет встроенного метода для этого. Создайте функцию, используя toUpperCase() и charAt().
		</p>
		<p>
			<button onclick="console.log(ucFirst('вася'))">запуск</button>
		</p>
		<p>
			Напишите функцию checkSpam(str), которая возвращает true, если строка str содержит „viagra“ или „XXX“, а иначе false.Функция должна быть нечувствительна к регистру:
			checkSpam('buy ViAgRA now') == true
			checkSpam('free xxxxx') == true
			checkSpam("innocent rabbit") == false
		</p>
		<p>
			<button onclick="console.log( checkSpam('XXX') )">запуск</button>
		</p>
		<p>
			Создайте функцию truncate(str, maxlength), которая проверяет длину строки str, и если она превосходит maxlength – заменяет конец str на "...", так чтобы ее длина стала равна maxlength.Результатом функции должна быть (при необходимости) усечённая строка.
			Например:
			truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) = "Вот, что мне хоте..."
			truncate("Всем привет!", 20) = "Всем привет!"
			Эта функция имеет применение в жизни. Она используется, чтобы усекать слишком длинные темы сообщений.
			P.S. В кодировке Unicode существует специальный символ «троеточие»: … (HTML: &hellip;), но в этой задаче подразумеваются именно три точки подряд.
		</p>
		<p>
			<button onclick="console.log( truncate('Вот, что мне хотелось бы сказать на эту тему', 20) )">запуск</button>
		</p>
		<p>
			Есть стоимость в виде строки: "$120". То есть, первым идёт знак валюты, а затем – число.Создайте функцию extractCurrencyValue(str), которая будет из такой строки выделять число-значение, в данном случае 120.
		</p>
		<button onclick="console.log( extractCurrencyValue('$120') )">запуск</button>
		<p><b>Объекты как ассоциативные массивы</b></p>
		<p>
			Мини-задача на синтаксис объектов. Напишите код, по строке на каждое действие.Создайте пустой объект user.
			Добавьте свойство name со значением Вася.
			Добавьте свойство surname со значением Петров.
			Поменяйте значение name на Сергей.
			Удалите свойство name из объекта.
		</p>
		<p>
			<button onclick="objectCreate()">запуск</button>
		</p>
		<p><b>Объекты: перебор свойств</b></p>
		<p>
			Создайте функцию isEmpty(obj), которая возвращает true, если в объекте нет свойств и false – если хоть одно свойство есть.Работать должно так:
			function isEmpty(obj) {
			/* ваш код */
			}
			var schedule = {};
			alert( isEmpty(schedule) ); // true
			schedule["8:30"] = "подъём";
			alert( isEmpty(schedule) ); // false
		</p>
		<p>
			<button onclick="console.log( isEmpty(schedule) );">запуск</button>
		</p>
		<p>
			Есть объект salaries с зарплатами. Напишите код, который выведет сумму всех зарплат.Если объект пустой, то результат должен быть 0.
			Например:
			"use strict";
			var salaries = {
			"Вася": 100,
			"Петя": 300,
			"Даша": 250
			};
			//... ваш код выведет 650
		</p>
		<p>
			<button onclick="console.log( sumSalaries(salaries) )">запуск</button>
		</p>
		<p>
			Есть объект salaries с зарплатами. Напишите код, который выведет имя сотрудника, у которого самая большая зарплата.Если объект пустой, то пусть он выводит «нет сотрудников».
			Например:
			"use strict";
			var salaries = {
			"Вася": 100,
			"Петя": 300,
			"Даша": 250
			};
			// ... ваш код выведет "Петя"
		</p>
		<p>
			<button onclick="console.log( whoIsRich(salaries) )">запуск</button>
		</p>
		<p>
			Создайте функцию multiplyNumeric, которая получает объект и умножает все численные свойства на 2. Например: // до вызова
			var menu = {
			width: 200,
			height: 300,
			title: "My menu"
			};
			multiplyNumeric(menu);
			// после вызова
			menu = {
			width: 400,
			height: 600,
			title: "My menu"
			};
			P.S. Для проверки на число используйте функцию:
			function isNumeric(n) {
			return !isNaN(parseFloat(n)) && isFinite(n)
			}
		</p>
		<p>
			<button onclick=" multiplyNumeric(menu)">запуск</button>
		</p>
		<p><b>Методы объекта, "this"</b></p>
		<p>Создайте объект calculator (калькулятор) с тремя методами:
		   read() (читать) запрашивает два значения и сохраняет их как свойства объекта.
		   sum() (суммировать) возвращает сумму сохранённых значений.
		   mul() (умножить) перемножает сохранённые значения и возвращает результат.
		   let calculator = {
		   // ... ваш код ...
		   };
		   calculator.read();
		   alert( calculator.sum() );
		   alert( calculator.mul() );</p>
		<p>
			<button onclick="console.log(calculate())">запуск</button>
		</p>
		<p>Это ladder (лестница) – объект, который позволяет подниматься вверх и спускаться:
		   let ladder = {
		   step: 0,
		   up() {
		   this.step++;
		   },
		   down() {
		   this.step--;
		   },
		   showStep: function() { // показывает текущую ступеньку
		   alert( this.step );
		   }
		   };
		   Теперь, если нам нужно сделать несколько последовательных вызовов, мы можем выполнить это так:
		   ladder.up();
		   ladder.up();
		   ladder.down();
		   ladder.showStep(); // 1
		   Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:
		   ladder.up().up().down().showStep(); // 1
		   Такой подход широко используется в библиотеках JavaScript.</p>
		<p>
			<button onclick="console.log(goLedder())">запуск</button>
			<button onclick="console.log(goLedder2())">запуск</button>
		</p>
		<p><b>Конструкторы, создание объектов через "new"</b></p>
		<p>
			Создайте функцию-конструктор Calculator, который создаёт объекты с тремя методами:
			read() запрашивает два значения при помощи prompt и сохраняет их значение в свойствах объекта.
			sum() возвращает сумму введённых свойств.
			mul() возвращает произведение введённых свойств.
			Например:
			let calculator = new Calculator();
			calculator.read();
			alert( "Sum=" + calculator.sum() );
			alert( "Mul=" + calculator.mul() );
		</p>
		<p>
			<button onclick="console.log(calcCreate())">запуск</button>
		</p>
		<p>
			Напишите функцию-конструктор Accumulator(startingValue).
			Объект, который она создаёт, должен уметь следующее:
			Хранить «текущее значение» в свойстве value. Начальное значение устанавливается в аргументе конструктора startingValue.
			Метод read() использует prompt для получения числа и прибавляет его к свойству value.
			Таким образом, свойство value является текущей суммой всего, что ввёл пользователь при вызовах метода read(), с учётом начального значения startingValue.
			Ниже вы можете посмотреть работу кода:
			let accumulator = new Accumulator(1); // начальное значение 1
			accumulator.read(); // прибавит ввод prompt к текущему значению
			accumulator.read(); // прибавит ввод prompt к текущему значению
			alert(accumulator.value); // выведет сумму этих значений
		</p>
		<p>
			<button onclick="console.log(showAccum())">запуск</button>
		</p>
		<p><b>Массивы с числовыми индексами</b></p>
		<p>
			Как получить последний элемент из произвольного массива?
			У нас есть массив goods. Сколько в нем элементов – не знаем, но можем прочитать из goods.length.
			Напишите код для получения последнего элемента goods.
		</p>
		<p>
			<button onclick="getLastFruit()">запуск</button>
		</p>
		<p>
			Как добавить элемент в конец произвольного массива?У нас есть массив goods. Напишите код для добавления в его конец значения «Компьютер».</p>
		<p>
			<button onclick="pushToArray()">запуск</button>
		</p>
		<p>
			Задача из 5 шагов-строк:Создайте массив styles с элементами «Джаз», «Блюз».
			Добавьте в конец значение «Рок-н-Ролл»
			Замените предпоследнее значение с конца на «Классика». Код замены предпоследнего значения должен работать для массивов любой длины.
			Удалите первое значение массива и выведите его alert.
			Добавьте в начало значения «Рэп» и «Регги».
			Массив в результате каждого шага:
			Джаз, Блюз
			Джаз, Блюз, Рок-н-Ролл
			Джаз, Классика, Рок-н-Ролл
			Классика, Рок-н-Ролл
			Рэп, Регги, Классика, Рок-н-Ролл
		</p>
		<p>
			<button onclick="unshiftArray()">запуск</button>
		</p>
		<p>
			Напишите код для вывода alert случайного значения из массива:
			var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"];
			P.S. Код для генерации случайного целого от min to max включительно:
			var rand = min + Math.floor(Math.random() * (max + 1 - min));
		</p>
		<p>
			<button onclick="alertRandom()">запуск</button>
		</p>
		<p>
			Напишите код, который:Запрашивает по очереди значения при помощи prompt и сохраняет их в массиве.
			Заканчивает ввод, как только посетитель введёт пустую строку, не число или нажмёт «Отмена».
			При этом ноль 0 не должен заканчивать ввод, это разрешённое число.
			Выводит сумму всех значений массива
		</p>
		<p>
			<button onclick="console.log(askGetSum())">запуск</button>
		</p>
		<p>
			Создайте функцию find(arr, value), которая ищет в массиве arr значение value и возвращает его номер, если найдено, или -1, если не найдено.Например:
			arr = ["test", 2, 1.5, false];
			find(arr, "test"); // 0
			find(arr, 2); // 1
			find(arr, 1.5); // 2
			find(arr, 0); // -1
		</p>
		<p>
			<button onclick="console.log(find(findArr, 82))">запуск</button>
		</p>
		<p>
			Создайте функцию filterRange(arr, a, b), которая принимает массив чисел arr и возвращает новый массив, который содержит только числа из arr из диапазона от a до b. То есть, проверка имеет вид a ≤ arr[i] ≤ b. Функция не должна менять arr.
			Пример работы:
			var arr = [5, 4, 3, 8, 0];
			var filtered = filterRange(arr, 3, 5);
			// теперь filtered = [5, 4, 3]
			// arr не изменился
		</p>
		<p>
			<button onclick="console.log(filterRange(filterArr, 3,5));console.log(filterArr)">запуск</button>
		</p>
		<p>
			Целое число, большее 1, называется простым, если оно не делится нацело ни на какое другое, кроме себя и 1.Древний алгоритм «Решето Эратосфена» для поиска всех простых чисел до n выглядит так:
			Создать список последовательных чисел от 2 до n: 2, 3, 4, ..., n.
			Пусть p=2, это первое простое число.
			Зачеркнуть все последующие числа в списке с разницей в p, т.е. 2*p, 3*p, 4*p и т.д. В случае p=2 это будут 4,6,8....
			Поменять значение p на первое не зачеркнутое число после p.
			Повторить шаги 3-4 пока p2 < n.
			Все оставшиеся не зачеркнутыми числа – простые.
			Посмотрите также анимацию алгоритма.
			Реализуйте «Решето Эратосфена» в JavaScript, используя массив.
			Найдите все простые числа до 100 и выведите их сумму.
		</p>
		<!--p: button(onclick='') запуск-->
		<p>
			На входе массив чисел, например: arr = [1, -2, 3, 4, -9, 6].Задача – найти непрерывный подмассив arr, сумма элементов которого максимальна.
			Ваша функция должна возвращать только эту сумму.
			Например:
			getMaxSubSum([-1, 2, 3, -9]) = 5 (сумма выделенных)
			getMaxSubSum([2, -1, 2, 3, -9]) = 6
			getMaxSubSum([-1, 2, 3, -9, 11]) = 11
			getMaxSubSum([-2, -1, 1, 2]) = 3
			getMaxSubSum([100, -9, 2, -3, 5]) = 100
			getMaxSubSum([1, 2, 3]) = 6 (неотрицательные - берем всех)
			Если все элементы отрицательные, то не берём ни одного элемента и считаем сумму равной нулю:
			getMaxSubSum([-1, -2, -3]) = 0
			Постарайтесь придумать решение, которое работает за O(n2), а лучше за O(n) операций.
		</p>
		<button onclick="console.log(getMaxSubSum(maxsum1))">запускfor</button>
		<button onclick="console.log(getMaxSubSum2(maxsum2))">запускforOf</button>
		<p><b>Массивы: методы</b></p>
		<p>
			В объекте есть свойство className, которое содержит список «классов» – слов, разделенных пробелом:
			var obj = {
			className: 'open menu'
			}
			Создайте функцию addClass(obj, cls), которая добавляет в список класс cls, но только если его там еще нет:
			addClass(obj, 'new'); // obj.className='open menu new'
			addClass(obj, 'open'); // без изменений (класс уже существует)
			addClass(obj, 'me'); // obj.className='open menu new me'
			alert( obj.className ); // "open menu new me"
			P.S. Ваша функция не должна добавлять лишних пробелов.
		</p>
		<button onclick="console.log(addClass(customClasses, 'open'))">запуск</button>
		<p>
			Напишите функцию camelize(str), которая преобразует строки вида «my-short-string» в «myShortString».
			То есть, дефисы удаляются, а все слова после них получают заглавную букву.
			Например:
			camelize("background-color") == 'backgroundColor';
			camelize("list-style-image") == 'listStyleImage';
			camelize("-webkit-transition") == 'WebkitTransition';
			Такая функция полезна при работе с CSS.
			P.S. Вам пригодятся методы строк charAt, split и toUpperCase.
		</p>
		<button onclick="console.log(camelize('background-color'))">запуск</button>
		<button onclick="console.log(camelize2('background-color'))">запуск</button>
		<p>
			У объекта есть свойство className, которое хранит список «классов» – слов, разделенных пробелами:
			var obj = {
			className: 'open menu'
			};
			Напишите функцию removeClass(obj, cls), которая удаляет класс cls, если он есть:
			removeClass(obj, 'open'); // obj.className='menu'
			removeClass(obj, 'blabla'); // без изменений (нет такого класса)
			P.S. Дополнительное усложнение. Функция должна корректно обрабатывать дублирование класса в строке:
			obj = {
			className: 'my menu menu'
			};
			removeClass(obj, 'menu');
			alert( obj.className ); // 'my'
			Лишних пробелов после функции образовываться не должно.
		</p>
		<button onclick="console.log(removeClass(customObject, 'add'))">запуск</button>
		<p>
			Создайте функцию filterRangeInPlace(arr, a, b), которая получает массив с числами arr и удаляет из него все числа вне диапазона a..b. То есть, проверка имеет вид a ≤ arr[i] ≤ b. Функция должна менять сам массив и ничего не возвращать. |апример:
			arr = [5, 3, 8, 1];
			filterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4
			alert( arr ); // массив изменился: остались [3, 1]
		</p>
		<button onclick="console.log(filterRangeInPlace(clearArr, 1, 4))">запуск</button>
		<p>
			Как отсортировать массив чисел в обратном порядке?var arr = [5, 2, 1, -10, 8];
			// отсортируйте?
			alert( arr ); // 8, 5, 2, 1, -10
		</p>
		<button onclick="console.log(sortReverse(sortReverseArr))">запуск</button>
		<p>
			Есть массив строк arr. Создайте массив arrSorted – из тех же элементов, но отсортированный.
			Исходный массив не должен меняться.
			var arr = ["HTML", "JavaScript", "CSS"];
			// ... ваш код ...
			alert( arrSorted ); // CSS, HTML, JavaScript
			alert( arr ); // HTML, JavaScript, CSS (без изменений)
			Постарайтесь сделать код как можно короче.
		</p>
		<button onclick="console.log(arrSorted(array))">запуск</button>
		<p>
			Используйте функцию sort для того, чтобы «перетрясти» элементы массива в случайном порядке.
			var arr = [1, 2, 3, 4, 5];
			arr.sort(ваша функция);
			alert( arr ); // элементы в случайном порядке, например [3,5,1,2,4]
		</p>
		<button onclick="console.log(randomShake(sortReverseArr))">запуск</button>
		<p>
			Создайте функцию конструктор Calculator, которая создаёт «расширяемые» объекты калькулятора.
			Задание состоит из двух частей.
			Во-первых, реализуйте метод calculate(str), который принимает строку типа "1 + 2" в формате «ЧИСЛО оператор ЧИСЛО» (разделено пробелами) и возвращает результат. Метод должен понимать плюс + и минус -.
			Пример использования:
			let calc = new Calculator;
			alert( calc.calculate("3 + 7") ); // 10
			Затем добавьте метод addMethod(name, func), который добавляет в калькулятор новые операции. Он принимает оператор name и функцию с двумя аргументами func(a,b), которая описывает его.
			Например, давайте добавим умножение *, деление / и возведение в степень **:
			let powerCalc = new Calculator;
			powerCalc.addMethod("*", (a, b) => a * b);
			powerCalc.addMethod("/", (a, b) => a / b);
			powerCalc.addMethod("**", (a, b) => a ** b);
			let result = powerCalc.calculate("2 ** 3");
			alert( result ); //
			Для этой задачи не нужны скобки или сложные выражения.
			Числа и оператор разделены ровно одним пробелом.
			Не лишним будет добавить обработку ошибок.
		</p>
		<!--<p>button</p>-->
		<p>
			Напишите код, который отсортирует массив объектов people по полю age.
			Например:
			var vasya = { name: "Вася", age: 23 };
			var masha = { name: "Маша", age: 18 };
			var vovochka = { name: "Вовочка", age: 6 };
			var people = [ vasya , masha , vovochka ];
			... ваш код ...
			// теперь people: [vovochka, masha, vasya]
			alert(people[0].age) // 6
			Выведите список имён в массиве после сортировки.
		</p>
		<button onclick="console.log(sortByAge(people))">запуск</button>
		<p>У вас есть массив объектов user, и в каждом из них есть user.name. Напишите код, который преобразует их в массив имён.
		   Например:
		   let vasya = { name: "Вася", age: 25 };
		   let petya = { name: "Петя", age: 30 };
		   let masha = { name: "Маша", age: 28 };
		   let users = [ vasya, petya, masha ];
		   let names = /* ... ваш код */
		   alert( names ); // Вася, Петя, Маша</p>
		<button onclick="console.log(getNames(users))">запуск</button>
		<p>У вас есть массив объектов user, и у каждого из объектов есть name, surname и id.
		   Напишите код, который создаст ещё один массив объектов с параметрами id и fullName, где fullName – состоит из name и surname.
		   Например:
		   let vasya = { name: "Вася", surname: "Пупкин", id: 1 };
		   let petya = { name: "Петя", surname: "Иванов", id: 2 };
		   let masha = { name: "Маша", surname: "Петрова", id: 3 };
		   let users = [ vasya, petya, masha ];
		   let usersMapped = /* ... ваш код ... */
		   /*
		   usersMapped = [
		   { fullName: "Вася Пупкин", id: 1 },
		   { fullName: "Петя Иванов", id: 2 },
		   { fullName: "Маша Петрова", id: 3 }
		   ]
		   */
		   alert( usersMapped[0].id ) // 1
		   alert( usersMapped[0].fullName ) // Вася Пупкин
		   Итак, на самом деле вам нужно трансформировать один массив объектов в другой. Попробуйте использовать =>. Это небольшая уловка.</p>
		<button onclick="console.log(getFullNames(users))">запуск</button>
		<p>Односвязный список – это структура данных, которая состоит из элементов, каждый из которых хранит ссылку на следующий. Последний элемент может не иметь ссылки, либо она равна null.</p>
		<!--p: button(onclick='') запуск-->
		<p>
			Анаграммы – слова, состоящие из одинакового количества одинаковых букв, но в разном порядке. Например:воз - зов
			киборг - гробик
			корсет - костер - сектор
			Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.
			Например:
			var arr = ["воз", "киборг", "корсет", "ЗОВ", "гробик", "костер", "сектор"];
			alert( aclean(arr) ); // "воз,киборг,корсет" или "ЗОВ,гробик,сектор"
			Из каждой группы анаграмм должно остаться только одно слово, не важно какое.
		</p>
		<button onclick="console.log(aclean(anagram))">запуск</button>
		<p>
			Пусть arr – массив строк.Напишите функцию unique(arr), которая возвращает массив, содержащий только уникальные элементы arr.
			Например:
			function unique(arr) {
			/* ваш код */
			}
			var strings = ["кришна", "кришна", "харе", "харе",
			"харе", "харе", "кришна", "кришна", "8-()"
			];
			alert( unique(strings) ); // кришна, харе, 8-()
		</p>
		<button onclick="console.log(unique(strings))">запуск</button>
		<p>
			Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы массива.
			Многократные прогоны через shuffle могут привести к разным последовательностям элементов. Например:
			let arr = [1, 2, 3];
			shuffle(arr);
			// arr = [3, 2, 1]
			shuffle(arr);
			// arr = [2, 1, 3]
			shuffle(arr);
			// arr = [3, 1, 2]
			// ...
			Все последовательности элементов должны иметь одинаковую вероятность. Например, [1,2,3] может быть переупорядочено как [1,2,3] или [1,3,2], или [3,1,2] и т.д., с равной вероятностью каждого случая.
		</p>
		<button onclick="console.log(shuffle(sortReverseArr))">запуск</button>
		<p>
			Напишите функцию getAverageAge(users), которая принимает массив объектов со свойством age и возвращает средний возраст.
			Формула вычисления среднего арифметического значения: (age1 + age2 + ... + ageN) / N.
			Например:
			let vasya = { name: "Вася", age: 25 };
			let petya = { name: "Петя", age: 30 };
			let masha = { name: "Маша", age: 29 };
			let arr = [ vasya, petya, masha ];
			alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
		</p>
		<button onclick="console.log(getAverageAge(people))">запуск</button>
		<p><b>Массив: перебирающие методы</b></p>
		<p><b>Массивы: методы</b></p>
		<p>Взятие N
		   Функция integers создает бесконечный итератор, который продолжает производить целые числа вечно.
		   Нужно создать функцию take, которая оборачивает данный итератор в другой итератор,
		   останавливающийся по достижении n элементов.
		   let iter = integers();
		   for (let elt of take(3, iter)) console.log(elt); // 0, 1, 2, 3
		</p>
		<!--p: button(onclick='') запуск-->
		<p>
			Код ниже получает из массива строк новый массив, содержащий их длины: var arr = ["Есть", "жизнь", "на", "Марсе"];
			var arrLength = [];
			for (var i = 0; i < arr.length; i++) {
			arrLength[i] = arr[i].length;
			lert( arrLength ); // 4,5,2,5
			ерепишите выделенный участок: уберите цикл, используйте вместо него метод map.
		</p>
		<p>
			<button onclick="forToMap()">запуск</button>
		</p>
		<p>
			На входе массив чисел, например: arr = [1,2,3,4,5].
			Напишите функцию getSums(arr), которая возвращает массив его частичных сумм.
			Иначе говоря, вызов getSums(arr) должен возвращать новый массив из такого же числа элементов, в котором на каждой позиции должна быть сумма элементов arr до этой позиции включительно.
			То есть:
			для arr = [ 1, 2, 3, 4, 5 ]
			getSums( arr ) = [ 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5 ] = [ 1, 3, 6, 10, 15 ]
			Еще пример: getSums([-2,-1,0,1]) = [-2,-3,-3,-2].
			Функция не должна модифицировать входной массив.
			В решении используйте метод arr.reduce.
			getMnoj массив с результатом умножения соседних эдементов
		</p>
		<p>
			<button onclick="console.log(getMnoj(nmbs))">запуск</button>
			<button onclick="console.log(getSums(nmbs))">запуск2</button>
		</p>
		<p><b>Псевдомассив аргументов "arguments"</b></p>
		<p>
			Как в функции отличить отсутствующий аргумент от undefined?
		</p>
		<p>
			<button onclick="console.log(argmnts())">запуск</button>
		</p>
		<p>
			Напишите функцию sum(...), которая возвращает сумму всех своих аргументов:
		</p>
		<p>
			<button onclick="console.log(argumentsSum(1,2,3))">запуск</button>
		</p>
		<p><b>Дата и время</b></p>
		<p>
			Создайте объект Date для даты: 20 февраля 2012 года, 3 часа 12 минут.Временная зона – местная. Выведите его на экран</p>
		<button onclick="console.log(createDate())">запуск</button>
		<p>
			Создайте функцию getWeekDay(date), которая выводит текущий день недели в коротком формате „пн“, „вт“, … „вс“.
			Например:
			var date = new Date(2012,0,3); // 3 января 2012
			alert( getWeekDay(date) ); // Должно вывести 'вт
		</p>
		<button onclick="console.log(getWeekDay(customDate))">запуск</button>
		<p>
			Напишите функцию, getLocalDay(date) которая возвращает день недели для даты date.День нужно возвратить в европейской нумерации, т.е. понедельник имеет номер 1, вторник номер 2, …, воскресенье – номер 7.
			var date = new Date(2012, 0, 3); // 3 янв 2012
			alert( getLocalDay(date) ); // вторник, выведет 2
		</p>
		<button onclick="console.log(getLocalDay(customDate))">запуск</button>
		<p>
			Создайте функцию getDateAgo(date, days), которая возвращает число, которое было days дней назад от даты date.Например, для 2 января 2015:
			var date = new Date(2015, 0, 2);
			alert( getDateAgo(date, 1) ); // 1, (1 января 2015)
			alert( getDateAgo(date, 2) ); // 31, (31 декабря 2014)
			alert( getDateAgo(date, 365) ); // 2, (2 января 2014)
			P.S. Важная деталь: в процессе вычислений функция не должна менять переданный ей объект date.
		</p>
		<button onclick="console.log(getDateAgo(customDate,2))">запуск</button>
		<p>
			Напишите функцию getLastDayOfMonth(), которая возвращает последний день месяца.
			Параметры:
			year – 4-значный год, например 2012.
			month – месяц от 0 до 11.
			Например, getLastDayOfMonth(2012, 1) = 29 (високосный год, февраль).
		</p>
		<button onclick="console.log(getLastDayOfMonth(2012, 1))">запуск</button>
		<p>
			Напишите функцию getSecondsToday() которая возвращает, сколько секунд прошло с начала сегодняшнего дня.
			Например, если сейчас 10:00 и не было перехода на зимнее/летнее время, то:
			getSecondsToday() == 36000 // (3600 * 10)
			Функция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.
		</p>
		<button onclick="console.log(getSecondsToday())">запуск</button>
		<p>
			Напишите функцию getSecondsToTomorrow() которая возвращает, сколько секунд осталось до завтра.Например, если сейчас 23:00, то:
			getSecondsToTomorrow() == 3600
			P.S. Функция должна работать в любой день, т.е. в ней не должно быть конкретного значения сегодняшней даты.
		</p>
		<button onclick="console.log(getSecondsToTomorrow())">запуск</button>
		<p>
			Напишите функцию formatDate(date), которая форматирует дату date так:
			Если со времени date прошло менее секунды, то возвращает "только что".
			Иначе если со времени date прошло менее минуты, то "n сек. назад".
			Иначе если прошло меньше часа, то "m мин. назад".
			Иначе полная дата в формате "дд.мм.гг чч:мм".
			Например:
			function formatDate(date) { /* ваш код */ }
			alert( formatDate(new Date(new Date - 1)) ); // "только что"
			alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 сек. назад"
			alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 мин. назад"
			alert( formatDate(new Date(new Date - 86400 * 1000)) ); // вчерашняя дата в формате "дд.мм.гг чч:мм"
		</p>
		<button onclick="console.log(returnFormatDate())">запуск</button>
		<p><b>Map и Set</b></p>
		<p>Допустим, у нас есть массив arr.
		   Создайте функцию unique(arr), которая вернёт массив уникальных, не повторяющихся значений массива arr.
		   Например:
		   function unique(arr) {
		   /* ваш код */
		   }
		   let values = ["Hare", "Krishna", "Hare", "Krishna",
		   "Krishna", "Krishna", "Hare", "Hare", ":-O"
		   ];
		   alert( unique(values) ); // Hare, Krishna, :-O
		   P.S. Здесь мы используем строки, но значения могут быть любого типа.
		   P.P.S. Используйте Set для хранения уникальных значений.</p>
		<button onclick="console.log(uniqSet(set))">запуск</button>
		<p>Анаграммы – это слова, у которых те же буквы в том же количестве, но они располагаются в другом порядке.
		   Например:
		   nap - pan
		   ear - are - era
		   cheaters - hectares - teachers
		   Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.
		   Например:
		   let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];
		   alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
		   Из каждой группы анаграмм должно остаться только одно слово, не важно какое
		</p>
		<button onclick="console.log(cleanArray(cleanarr))">запуск</button>
		<button onclick="console.log(arrclean(cleanarr))">запуск</button>
		<p>Мы хотели бы получить массив ключей map.keys() в переменную и далее работать с ними, например, применить метод .push.
		   Но это не выходит:
		   let map = new Map();
		   map.set("name", "John");
		   let keys = map.keys();
		   // Error: keys.push is not a function
		   // Ошибка: keys.push -- это не функция
		   keys.push("more");
		   Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?
		</p>
		<button onclick="console.log(pushMore())">запуск</button>
		<p><b>WeakMap и WeakSet</b></p>
		<p>Есть массив сообщений:
		   let messages = [
		   {text: "Hello", from: "John"},
		   {text: "How goes?", from: "John"},
		   {text: "See you soon", from: "Alice"}
		   ];
		   У вас есть к ним доступ, но управление этим массивом происходит где-то ещё. Добавляются новые сообщения и удаляются старые, и вы не знаете в какой момент это может произойти.
		   Имея такую вводную информацию, решите, какую структуру данных вы могли бы использовать для ответа на вопрос «было ли сообщение прочитано?». Структура должна быть подходящей, чтобы можно было однозначно сказать, было ли прочитано это сообщение для каждого объекта сообщения.
		   P.S. Когда сообщение удаляется из массива messages, оно должно также исчезать из структуры данных.
		   P.P.S. Нам не следует модифицировать сами объекты сообщений, добавлять туда свойства. Если сообщения принадлежат какому-то другому коду, то это может привести к плохим последствиям.</p>
		<button onclick="console.log(delMessages())">запуск</button>
		<p>
			Есть массив сообщений такой же, как и в предыдущем задании.
			let messages = [
			{ text: "Hello", from: "John" },
			{ text: "How goes?", from: "John" },
			{ text: "See you soon", from: "Alice" }
			];
			Теперь вопрос стоит так: какую структуру данных вы бы предложили использовать для хранения информации о том, когда сообщение было прочитано?
			В предыдущем задании нам нужно было сохранить только факт прочтения «да или нет». Теперь же нам нужно сохранить дату, и она должна исчезнуть из памяти при удалении «сборщиком мусора» сообщения.
			P.S. Даты в JavaScript можно хранить как объекты встроенного класса Date, которые мы разберём позднее.
		</p>
		<button onclick="console.log(saveDateMessages())">запуск</button>
		<p><b> Object.keys, values, entries </b></p>
		<p>
			Есть объект salaries с произвольным количеством свойств, содержащих заработные платы.
			Напишите функцию sumSalaries(salaries), которая возвращает сумму всех зарплат с помощью метода Object.values и цикла for..of.
			Если объект salaries пуст, то результат должен быть 0.
			Например:
			let salaries = {
			"John": 100,
			"Pete": 300,
			"Mary": 250
			};
			alert( sumSalaries(salaries) ); // 650
		</p>
		<button onclick="console.log(getSumSalaries(salaries))">запуск</button>
		<button onclick="console.log(getSumSalaries2(salaries))">запуск</button>
		<p>
			Напишите функцию count(obj), которая возвращает количество свойств объекта:
			let user = {
			name: 'John',
			age: 30
			};
			alert( count(user) ); // 2
			Постарайтесь сделать код как можно короче.
			P.S. Игнорируйте символьные свойства, подсчитывайте только «обычные».
		</p>
		<button onclick="console.log(countObjProps(user))">запуск</button>
		<p><b> Деструктурирующее присваивание </b></p>
		<p>У нас есть объект:
		   let user = {
		   name: "John",
		   years: 30
		   };
		   Напишите деструктурирующее присваивание, которое:
		   свойство name присвоит в переменную name.
		   свойство years присвоит в переменную age.
		   свойство isAdmin присвоит в переменную isAdmin (false, если нет такого свойства)
		   Пример переменных после вашего присваивания:
		   let user = { name: "John", years: 30 };
		   // ваш код должен быть с левой стороны:
		   // ... = user
		   alert( name ); // John
		   alert( age ); // 30
		   alert( isAdmin ); // false</p>
		<button onclick="console.log(destructObj(user))">запуск</button>
		<p>У нас есть объект salaries с зарплатами:
		   let salaries = {
		   "John": 100,
		   "Pete": 300,
		   "Mary": 250
		   };
		   Создайте функцию topSalary(salaries), которая возвращает имя самого высокооплачиваемого сотрудника.
		   Если объект salaries пустой, то нужно вернуть null.
		   Если несколько высокооплачиваемых сотрудников, можно вернуть любого из них.
		   P.S. Используйте Object.entries и деструктурирование, чтобы перебрать пары ключ/значение.</p>
		<button onclick="console.log(getRichGye(salaries))">запуск</button>
		<p><b> Формат JSON, метод toJSON </b></p>
		<p>Преобразуйте user в JSON, затем прочитайте этот JSON в другую переменную.
		   let user = {
		   name: "Василий Иванович",
		   age: 35
		   };</p>
		<button onclick="console.log(json())">запуск</button>
		<p>
			В простых случаях циклических ссылок мы можем исключить свойство, из-за которого они возникают, из сериализации по его имени.
			Но иногда мы не можем использовать имя, так как могут быть и другие, нужные, свойства с этим именем во вложенных объектах. Поэтому можно проверять свойство по значению.
			Напишите функцию replacer для JSON-преобразования, которая удалит свойства, ссылающиеся на meetup:
			let room = {
			number: 23
			};
			let meetup = {
			title: "Совещание",
			occupiedBy: [{name: "Иванов"}, {name: "Петров"}],
			place: room
			};
			// цикличные ссылки
			room.occupiedBy = meetup;
			meetup.self = meetup;
			alert( JSON.stringify(meetup, function replacer(key, value) {
			/* ваш код */
			}));
			/* в результате должно быть:
			{
			"title":"Совещание",
			"occupiedBy":[{"name":"Иванов"},{"name":"Петров"}],
			"place":{"number":23}
			}
			*/
		</p>
		<button onclick="console.log(circleLink(meetup))">запуск</button>
		<p><b> Рекурсия и стек </b></p>
		<p>
			Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
			Например:
			sumTo(1) = 1
			sumTo(2) = 2 + 1 = 3
			sumTo(3) = 3 + 2 + 1 = 6
			sumTo(4) = 4 + 3 + 2 + 1 = 10
			...
			sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
			Сделайте три варианта решения:
			С использованием цикла.
			Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.
			С использованием формулы арифметической прогрессии.
			Пример работы вашей функции:
			function sumTo(n) { /*... ваш код ... */ }
			alert( sumTo(100) ); // 5050
			P.S. Какой вариант решения самый быстрый? Самый медленный? Почему?
			P.P.S. Можно ли при помощи рекурсии посчитать sumTo(100000)?
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
			Определение факториала можно записать как:
			n! = n * (n - 1) * (n - 2) * ...*1
			Примеры значений для разных n:
			1! = 1
			2! = 2 * 1 = 2
			3! = 3 * 2 * 1 = 6
			4! = 4 * 3 * 2 * 1 = 24
			5! = 5 * 4 * 3 * 2 * 1 = 120
			Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.
			alert( factorial(5) ); // 120
			P.S. Подсказка: n! можно записать как n * (n-1)! Например: 3! = 3*2! = 3*2*1! = 6
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Числа Фибоначчи
			важность: 5
			Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
			Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
			Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.
			Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.
			Пример работы:
			function fib(n) { /* ваш код */ }
			alert(fib(3)); // 2
			alert(fib(7)); // 13
			alert(fib(77)); // 5527939700884757
			P.S. Все запуски функций из примера выше должны работать быстро. Вызов fib(77) должен занимать не более доли секунды.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):
			let list = {
			value: 1,
			next: {
			value: 2,
			next: {
			value: 3,
			next: {
			value: 4,
			next: null
			}
			}
			}
			};
			Напишите функцию printList(list), которая выводит элементы списка по одному.
			Сделайте два варианта решения: используя цикл и через рекурсию.
			Как лучше: с рекурсией или без?
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Выведите односвязный список из предыдущего задания Вывод односвязного списка в обратном порядке.
			Сделайте два решения: с использованием цикла и через рекурсию.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Замыкание </b></p>
		<p>
			Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.
			Да, именно таким образом, используя двойные круглые скобки (не опечатка).
			Например:
			sum(1)(2) = 3
			sum(5)(-1) = 4
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f. Если она возвращает true, то элемент добавится в возвращаемый массив.
			Сделайте набор «готовых к употреблению» фильтров:
			inBetween(a, b) – между a и b (включительно).
			inArray([...]) – находится в данном массиве.
			Они должны использоваться таким образом:
			arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
			arr.filter(inArray([1,2,3])) – выбирает только элементы, совпадающие с одним из элементов массива
			Например:
			/* .. ваш код для inBetween и inArray */
			let arr = [1, 2, 3, 4, 5, 6, 7];
			alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
			alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			У нас есть массив объектов, который нужно отсортировать:
			let users = [
			{ name: "John", age: 20, surname: "Johnson" },
			{ name: "Pete", age: 18, surname: "Peterson" },
			{ name: "Ann", age: 19, surname: "Hathaway" }
			];
			Обычный способ был бы таким:
			// по имени (Ann, John, Pete)
			users.sort((a, b) => a.name > b.name ? 1 : -1);
			// по возрасту (Pete, Ann, John)
			users.sort((a, b) => a.age > b.age ? 1 : -1);
			Можем ли мы сделать его короче, скажем, вот таким?
			users.sort(byField('name'));
			users.sort(byField('age'));
			То есть, чтобы вместо функции, мы просто писали byField(fieldName).
			Напишите функцию byField, которая может быть использована для этого.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Следующий код создаёт массив из стрелков (shooters).
			Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так…
			function makeArmy() {
			let shooters = [];
			let i = 0;
			while (i < 10) {
			let shooter = function() { // функция shooter
			alert( i ); // должна выводить порядковый номер
			};
			shooters.push(shooter);
			i++;
			}
			return shooters;
			}
			let army = makeArmy();
			army[0](); // у 0-го стрелка будет номер 10
			army[5](); // и у 5-го стрелка тоже будет номер 10
			// ... у всех стрелков будет номер 10, вместо 0, 1, 2, 3...
			Почему у всех стрелков одинаковые номера? Почините код, чтобы он работал как задумано.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Объект функции, NFE </b></p>
		<p>
			Измените код makeCounter() так, чтобы счётчик мог увеличивать и устанавливать значение:
			counter() должен возвращать следующее значение (как и раньше).
			counter.set(value) должен устанавливать счётчику значение value.
			counter.decrease() должен уменьшать значение счётчика на 1.
			Посмотрите код из песочницы с полным примером использования.
			P.S. Для того, чтобы сохранить текущее значение счётчика, можно воспользоваться как замыканием, так и свойством функции. Или сделать два варианта решения: и так, и так.
			Открыть песочницу с тестами для задачи.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Напишите функцию sum, которая бы работала следующим образом:
			sum(1)(2) == 3; // 1 + 2
			sum(1)(2)(3) == 6; // 1 + 2 + 3
			sum(5)(-1)(2) == 6
			sum(6)(-1)(-2)(-3) == 0
			sum(0)(1)(2)(3)(4)(5) == 15
			P.S. Подсказка: возможно вам стоит сделать особый метод преобразования в примитив для функции.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Планирование: setTimeout и setInterval</b></p>
		<p>
			Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.
			Сделайте два варианта решения.
			Используя setInterval.
			Используя рекурсивный setTimeout.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			В приведённом ниже коде запланирован вызов setTimeout, а затем выполняется сложное вычисление, для завершения которого требуется более 100 мс.
			Когда будет выполнена запланированная функция?
			После цикла.
			Перед циклом.
			В начале цикла.
			Что покажет alert?
			let i = 0;
			setTimeout(() => alert(i), 100); // ?
			// предположим, что время выполнения этой функции >100 мс
			for(let j = 0; j < 100000000; j++) {
			i++;
			}
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Декораторы и переадресация вызова, сall/apply </b></p>
		<p>
			Создайте декоратор spy(func), который должен возвращать обёртку, которая сохраняет все вызовы функции в своём свойстве calls.
			Каждый вызов должен сохраняться как массив аргументов.
			Например:
			function work(a, b) {
			alert( a + b ); // произвольная функция или метод
			}
			work = spy(work);
			work(1, 2); // 3
			work(4, 5); // 9
			for (let args of work.calls) {
			alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
			}
			P.S.: Этот декоратор иногда полезен для юнит-тестирования. Его расширенная форма – sinon.spy – содержится в библиотеке Sinon.JS.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд. Например:
			function f(x) {
			alert(x);
			}
			// создаём обёртки
			let f1000 = delay(f, 1000);
			let f1500 = delay(f, 1500);
			f1000("test"); // показывает "test" после 1000 мс
			f1500("test"); // показывает "test" после 1500 мс
			Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».
			В приведённом выше коде f – функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст this.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Результатом декоратора debounce(f, ms) должна быть обёртка, которая передаёт вызов f не более одного раза в ms миллисекунд. Другими словами, когда мы вызываем debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.
			Например:
			let f = debounce(alert, 1000);
			f(1); // выполняется немедленно
			f(2); // проигнорирован
			setTimeout( () => f(3), 100); // проигнорирован (прошло только 100 мс)
			setTimeout( () => f(4), 1100); // выполняется
			setTimeout( () => f(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
			На практике debounce полезен для функций, которые получают/обновляют данные, и мы знаем, что повторный вызов в течение короткого промежутка времени не даст ничего нового. Так что лучше не тратить на него ресурсы.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку, передавая вызов в f не более одного раза в ms миллисекунд. Те вызовы, которые попадают в период «торможения», игнорируются.
			Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.
			Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.
			Например, мы хотим отслеживать движения мыши.
			В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду (каждые 10 мс).
			Мы бы хотели обновлять информацию на странице при передвижениях.
			…Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Да и нет смысла делать обновление чаще, чем один раз в 100 мс.
			Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 100) как функцию, которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но передавать вызов в update() максимум раз в 100 мс.
			Визуально это будет выглядеть вот так:
			Для первого движения указателя декорированный вариант сразу передаёт вызов в update. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.
			Затем, когда указатель продолжает движение, в течение 100 мс ничего не происходит. Декорированный вариант игнорирует вызовы.
			По истечению 100 мс происходит ещё один вызов update с последними координатами.
			Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 100 мс, и затем вызывает update с последними координатами. В итоге окончательные координаты указателя тоже обработаны.
			Пример кода:
			function f(a) {
			console.log(a)
			}
			// f1000 передаёт вызовы f максимум раз в 1000 мс
			let f1000 = throttle(f, 1000);
			f1000(1); // показывает 1
			f1000(2); // (ограничение, 1000 мс ещё нет)
			f1000(3); // (ограничение, 1000 мс ещё нет)
			// когда 1000 мс истекли ...
			// ...выводим 3, промежуточное значение 2 было проигнорировано
			P.S. Аргументы и контекст this, переданные в f1000, должны быть переданы в оригинальную f.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p><b> Привязка контекста к функции </b></p>
		<p>
			Вызов askPassword() в приведённом ниже коде должен проверить пароль и затем вызвать user.loginOk/loginFail в зависимости от ответа.
			Однако, его вызов приводит к ошибке. Почему?
			Исправьте выделенную строку, чтобы всё работало (других строк изменять не надо).
			function askPassword(ok, fail) {
			let password = prompt("Password?", '');
			if (password == "rockstar") ok();
			else fail();
			}
			let user = {
			name: 'Вася',
			loginOk() {
			alert(`${this.name} logged in`);
			},
			loginFail() {
			alert(`${this.name} failed to log in`);
			},
			};
			askPassword(user.loginOk, user.loginFail);
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
		<p>
			Это задание является немного усложнённым вариантом одного из предыдущих – Исправьте функцию, теряющую "this".
			Объект user был изменён. Теперь вместо двух функций loginOk/loginFail у него есть только одна – user.login(true/false).
			Что нужно передать в вызов функции askPassword в коде ниже, чтобы она могла вызывать функцию user.login(true) как ok и функцию user.login(false) как fail?
			function askPassword(ok, fail) {
			let password = prompt("Password?", '');
			if (password == "rockstar") ok();
			else fail();
			}
			let user = {
			name: 'John',
			login(result) {
			alert( this.name + (result ? ' logged in' : ' failed to log in') );
			}
			};
			askPassword(?, ?); // ?
			Ваши изменения должны затрагивать только выделенный фрагмент кода.
		</p>
		<!--<button onclick="console.log()">запуск</button>-->
	</div>
</div>
</body>
</html>